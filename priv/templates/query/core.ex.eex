defmodule ExAws.<%= @module %>.Core do
  @actions [
<%=
    @api["operations"]
    |> Map.keys
    |> Enum.map(&("    \"#{&1}\""))
    |> Enum.join(",\n")
  %>]

  @moduledoc """
  ## <%= @metadata["serviceFullName"] %>

<%= @docs["service"] |> ExAwsGen.DocParser.format %>
  """

<%= @type_info[:typespec] %>
<%= for {op, %{"input" => %{"shape" => input}}} <- @api["operations"] do %>
<%=
  function = Mix.Utils.underscore(op)
%>
  @doc """
  <%= op %>

<%= @docs["operations"][op] %>
  """
  @spec <%= function %>(client :: ExAws.<%= @module %>.t, input :: <%= @type_info[:aliases] |> HashDict.fetch!(input) %>) :: ExAws.Request.<%= @protocol |> ExAwsGen.Service.protocol_name %>.response_t
  def <%= function %>(client, input) do
    request(client, "<%= op %>", input)
  end

  @doc """
  Same as `<%= function %>/2` but raise on error.
  """
  @spec <%= function %>!(client :: ExAws.<%= @module %>.t, input :: <%= @type_info[:aliases] |> HashDict.fetch!(input) %>) :: ExAws.Request.<%= @protocol |> ExAwsGen.Service.protocol_name %>.success_t | no_return
  def <%= function %>!(client, input) do
    case <%= function %>(client, input) do
      {:ok, results} -> results
      error -> raise "Error #{inspect(error)}"
    end
  end
<%= end %>

  defp request(%{__struct__: client_module} = client, action, input) do
    apply(client_module, :request, [client, action, input])
  end
end
